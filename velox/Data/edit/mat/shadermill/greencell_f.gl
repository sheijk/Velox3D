/******************************************************************************
 * The following code was generated by the mental mill(tm)                    *
 *                                                                            *
 * Copyright 1986-2007 by mental images GmbH, Fasanenstr. 81, D-10623         *
 * Berlin, Germany. All rights reserved.                                      *
/*****************************************************************************/

//
// The state structure is used internally within the fragment shader to
// commonly used values.
//
struct State
{
	vec4 tex_coord[4];
	vec3 tex_tangent[1];
	vec3 tex_binormal[1];
	float refracted_ior;
	float incident_ior;
	vec3 origin;
	vec3 position;
	vec3 normal;
	vec3 motion;
	vec2 raster;
	vec3 direction;
	float ray_length;
	float dot_nd;
	mat3 tangent_space[1];
	float importance;
	vec3 texture_du[256];
	vec3 texture_dv[256];
	vec4 volume_input;
	vec3 light_position;
	vec3 light_direction;
	vec3 light_to_surface;
	float light_distance;
	float light_dotnl;
	int light_type;
	float light_spread;
	float light_spread_cos;
	float light_distance_limit;
};

//
// Values for the light_type parameter of light shaders
//
const int LIGHT_POINT    = 0;
const int LIGHT_SPOT     = 1;
const int LIGHT_INFINITE = 2;
const int LIGHT_PLANAR   = 3;

//
// The light iterator structure holds the return values resulting from
// evaluating a light.
//
struct Light_iterator {
	vec3 point;
	vec3 direction;
	float distance;
	float dot_nl;
	vec4 contribution;
	vec4 raw_contribution;
	vec4 shadow;
	int count;
};

struct Ray {
	vec3 origin;
	vec3 direction;
};

vec4 illumination(float ndotl,float ndoth,float m);

float log10(float x);
vec2 log10(vec2 x);
vec3 log10(vec3 x);
vec4 log10(vec4 x);

float modf(float a,out float b);
vec2 modf(vec2 a,out vec2 b);
vec3 modf(vec3 a,out vec3 b);
vec4 modf(vec4 a,out vec4 b);

float round(float x);
vec2 round(vec2 x);
vec3 round(vec3 x);
vec4 round(vec4 x);

float saturate(float x);
vec2 saturate(vec2 x);
vec3 saturate(vec3 x);
vec4 saturate(vec4 x);

void sincos(float x,out float s,out float c);
void sincos(vec2 x,out vec2 s,out vec2 c);
void sincos(vec3 x,out vec3 s,out vec3 c);
void sincos(vec4 x,out vec4 s,out vec4 c);

mat2 transpose(mat2);
mat3 transpose(mat3);
mat4 transpose(mat4);

void mi_component_illumination_base(vec4 msl_ambient_color,float msl_ambient_scalar,vec4 msl_diffuse_reflectance_color,vec4 msl_diffuse_color,float msl_diffuse_scalar,vec4 msl_specular_reflectance_color,vec4 msl_specular_color,float msl_specular_scalar,out vec4 msl_sum,out vec4 msl_ambient,out vec4 msl_diffuse,out vec4 msl_specular)
{
	msl_sum = vec4(0, 0, 0, 0);
	msl_ambient = vec4(0, 0, 0, 0);
	msl_diffuse = vec4(0, 0, 0, 0);
	msl_specular = vec4(0, 0, 0, 0);
	msl_ambient = ((msl_ambient_color * vec4(msl_ambient_scalar)));
	msl_sum += msl_ambient;
	vec4 msl_0 = msl_diffuse_reflectance_color * msl_diffuse_color;
	msl_diffuse += ((msl_0 * vec4(msl_diffuse_scalar)));
	msl_sum += msl_diffuse;
	vec4 msl_1 = msl_specular_reflectance_color * msl_specular_color;
	msl_specular += ((msl_1 * vec4(msl_specular_scalar)));
	msl_sum += msl_specular;
	msl_sum.a = 1.0;
	msl_ambient.a = 1.0;
	msl_diffuse.a = 1.0;
	msl_specular.a = 1.0;
}


float mi_ashikhmin_shirley_diffuse(vec3 msl_lightDir,vec3 msl_eyeDir,vec3 msl_n,float msl_Rd,float msl_Rs)
{
	float msl_d;
	float msl_s1, msl_s2, msl_s3;
	float msl_0 = 1.0 - msl_Rs;
	msl_s1 = ((((((float(28) * msl_Rd)) / ((float(23) * 3.14159265358979323846)))) * ((msl_0 < 0.000000) ? 0.000000 : ((1.000000 < msl_0) ? 1.000000 : msl_0))));
	msl_s2 = ((float(1) - pow(float(1) - ((dot(msl_n,msl_lightDir) / float(2))),float(5))));
	msl_s3 = ((float(1) - pow(float(1) - (((-dot(msl_n,msl_eyeDir)) / float(2))),float(5))));
	msl_d = ((((msl_s1 * msl_s2)) * msl_s3));
	msl_d *= 3.14159265358979323846;
	return max(0.0,msl_d);
}


float mi_ashikhmin_shirley_specular(float msl_shininess_u,float msl_shininess_v,vec3 msl_lightDir,vec3 msl_eyeDir,vec3 msl_n,vec3 msl_u,vec3 msl_v)
{
	float msl_s;
	msl_s = 0.0;
	vec3 msl_h;
	msl_h = ((msl_lightDir - msl_eyeDir));
	msl_h = normalize(msl_h);
	float msl_nu = msl_shininess_u;
	float msl_nv = msl_shininess_v;
	float msl_s1, msl_s2, msl_s3, msl_s4;
	msl_s1 = ((sqrt(((((msl_nu + float(1))) * ((msl_nv + float(1)))))) / ((float(8) * 3.14159265358979323846))));
	float msl_nh, msl_hu, msl_hv, msl_hn, msl_hk, msl_nk1, msl_nk2, msl_kh;
	msl_nh = dot(msl_n,msl_h);
	msl_hn = dot(msl_h,msl_n);
	msl_hu = dot(msl_h,msl_u);
	msl_hv = dot(msl_h,msl_v);
	msl_hk = dot(msl_h,msl_lightDir);
	msl_nk1 = (-dot(msl_n,msl_eyeDir));
	msl_nk2 = dot(msl_n,msl_lightDir);
	msl_kh = dot(msl_lightDir,msl_h);
	msl_hu = ((msl_hu * msl_hu));
	msl_hv = ((msl_hv * msl_hv));
	msl_s2 = pow(msl_nh,((((msl_nu * msl_hu)) + ((msl_nv * msl_hv)))) / max(float(1) - ((msl_hn * msl_hn)),0.0001));
	msl_s3 = ((msl_hk * max(msl_nk1,msl_nk2)));
	msl_s4 = msl_kh;
	msl_s = ((((((msl_s1 * msl_s2)) / msl_s3)) * msl_s4));
	msl_s *= 3.14159265358979323846;
	return max(0.0,msl_s);
}


float mi_SQR(float msl_x)
{
	return msl_x * msl_x;
}


vec4 mi_cooktorr_specular(vec3 msl_di,vec3 msl_dr,vec3 msl_n,float msl_roughness,vec4 msl_ior)
{
	vec4 msl_result;
	vec4 msl_F, msl_g;
	vec3 msl_fhalf;
	float msl_nh, msl_nv, msl_nl, msl_vh, msl_nh2, msl_m2, msl_t;
	float msl_D, msl_G, msl_c, msl_otherterms, msl_expo;
	msl_fhalf = ((msl_dr - msl_di));
	msl_fhalf = normalize(msl_fhalf);
	msl_nh = dot(msl_n,msl_fhalf);
	msl_result.rgba = vec4(0, 0, 0, 0);
	if (msl_nh > 0.0)
	{
		msl_nl = dot(msl_n,msl_dr);
		msl_nv = (-dot(msl_n,msl_di));
		msl_vh = (-dot(msl_di,msl_fhalf));
		msl_nh2 = ((msl_nh * msl_nh));
		msl_m2 = ((msl_roughness * msl_roughness));
		msl_expo = ((((msl_nh2 - float(1))) / ((msl_nh2 * msl_m2))));
		msl_D = ((exp(msl_expo) / ((((((((float(4) * 3.14159265358979323846)) * msl_m2)) * msl_nh2)) * msl_nh2))));
		msl_G = ((((((2.0 * msl_nh)) * min(msl_nv,msl_nl))) / msl_vh));
		msl_G = min(msl_G,1.0);
		msl_c = dot(msl_dr,msl_fhalf);
		msl_t = ((msl_ior.r < float(1)) ? 1 : msl_ior.r);
		msl_g.r = sqrt(((((((msl_t * msl_t)) + ((msl_c * msl_c)))) - float(1))));
		msl_t = ((msl_ior.g < float(1)) ? 1 : msl_ior.g);
		msl_g.g = sqrt(((((((msl_t * msl_t)) + ((msl_c * msl_c)))) - float(1))));
		msl_t = ((msl_ior.b < float(1)) ? 1 : msl_ior.b);
		msl_g.b = sqrt(((((((msl_t * msl_t)) + ((msl_c * msl_c)))) - float(1))));
		msl_F.r = ((((((0.5 * mi_SQR(((msl_g.r - msl_c))))) / mi_SQR(((msl_g.r + msl_c))))) * ((float(1) + ((mi_SQR(((((msl_c * ((msl_g.r + msl_c)))) - float(1)))) / mi_SQR(((((msl_c * ((msl_g.r - msl_c)))) + float(1))))))))));
		msl_F.g = ((((((0.5 * mi_SQR(((msl_g.g - msl_c))))) / mi_SQR(((msl_g.g + msl_c))))) * ((float(1) + ((mi_SQR(((((msl_c * ((msl_g.g + msl_c)))) - float(1)))) / mi_SQR(((((msl_c * ((msl_g.g - msl_c)))) + float(1))))))))));
		msl_F.b = ((((((0.5 * mi_SQR(((msl_g.b - msl_c))))) / mi_SQR(((msl_g.b + msl_c))))) * ((float(1) + ((mi_SQR(((((msl_c * ((msl_g.b + msl_c)))) - float(1)))) / mi_SQR(((((msl_c * ((msl_g.b - msl_c)))) + float(1))))))))));
		msl_otherterms = ((msl_G != 0.0) ? ((((msl_D * msl_G)) / ((((3.14159265358979323846 * msl_nv)) * msl_nl)))) : ((msl_D / ((3.14159265358979323846 * msl_nl)))));
		msl_result = ((msl_F * vec4(msl_otherterms)));
	}
	return msl_result;
}


float mi_falloff(vec3 msl_direction,vec3 msl_normal,float msl_amount)
{
	float msl_f;
	float msl_0 = dot(-msl_direction,msl_normal);
	msl_f = ((msl_0 < 0.000000) ? 0.000000 : ((1.000000 < msl_0) ? 1.000000 : msl_0));
	msl_f = ((1.0 - pow(msl_f,1.0 / msl_amount)));
	return msl_f;
}


float mi_orennayar_diffuse(vec3 msl_lightDir,vec3 msl_eyeDir,vec3 msl_n,float msl_diffuse_deviation)
{
	float msl_res = 0.0;
	float msl_A, msl_B, msl_alpha, msl_beta;
	float msl_sigma, msl_sigma2;
	msl_sigma = msl_diffuse_deviation;
	msl_sigma2 = ((msl_sigma * msl_sigma));
	msl_A = ((1.0 - ((msl_sigma2 / ((2.0 * ((msl_sigma2 + 0.33))))))));
	msl_B = ((((0.45 * msl_sigma2)) / ((msl_sigma2 + 0.09))));
	float msl_phiI, msl_phiO, msl_sinThetaI, msl_sinThetaO;
	msl_sinThetaI = sqrt(max(float(0),float(1) - ((msl_lightDir.y * msl_lightDir.y))));
	msl_sinThetaO = sqrt(max(float(0),float(1) - ((msl_eyeDir.y * msl_eyeDir.y))));
	msl_phiI = ((msl_sinThetaI * atan(msl_lightDir.x,msl_lightDir.z)));
	msl_phiO = ((msl_sinThetaO * atan(msl_eyeDir.x,msl_eyeDir.z)));
	float msl_sinAlpha, msl_tanBeta;
	if (abs(msl_lightDir.y) > abs(msl_eyeDir.y))
	{
		msl_sinAlpha = msl_sinThetaO;
		msl_tanBeta = ((msl_sinThetaI / abs(msl_lightDir.y)));
	}
	else
	{
		msl_sinAlpha = msl_sinThetaI;
		msl_tanBeta = ((msl_sinThetaO / abs(msl_eyeDir.y)));
	}
	float msl_l;
	msl_l = dot(msl_lightDir,msl_n);
	float msl_0 = ((((msl_l * 1.0)) / 3.14159)) * ((msl_A + ((((((msl_B * max(float(0),cos(((msl_phiI - msl_phiO)))))) * msl_sinAlpha)) * msl_tanBeta))));
	msl_res = ((msl_0 < 0.000000) ? 0.000000 : ((1.000000 < msl_0) ? 1.000000 : msl_0));
	msl_res *= 3.14159265358979323846;
	return msl_res;
}


float mi_phong_specular(vec3 msl_lightDir,vec3 msl_eyeDir,vec3 msl_n,float msl_specular_shininess)
{
	float msl_res = 0.0;
	vec3 msl_half = msl_lightDir - msl_eyeDir;
	float msl_phi = dot(msl_half,msl_n);
	msl_phi *= ((msl_phi / dot(msl_half,msl_half)));
	if (msl_phi > 0.0)
	{
		msl_res = exp(((((log(msl_phi) * 0.5)) * msl_specular_shininess)));
	}
	return msl_res;
}


float mi_ward_anisglossy(vec3 msl_di,vec3 msl_dr,vec3 msl_n,vec3 msl_u,vec3 msl_v,float msl_shiny_u,float msl_shiny_v)
{
	vec3 msl_h;
	float msl_cosr, msl_cosi, msl_shiny_u2, msl_shiny_v2;
	float msl_hn, msl_hu, msl_hv, msl_expo;
	float msl_result = float(0);
	msl_cosr = dot(msl_dr,msl_n);
	msl_cosi = (-dot(msl_di,msl_n));
	if (((msl_cosi * msl_cosr)) >= 0.0001)
	{
		msl_shiny_u2 = ((msl_shiny_u * msl_shiny_u));
		msl_shiny_v2 = ((msl_shiny_v * msl_shiny_v));
		msl_h = ((msl_dr - msl_di));
		msl_h = normalize(msl_h);
		msl_hn = dot(msl_h,msl_n);
		msl_hn *= msl_hn;
		if (msl_hn > 1.0)
		{
			msl_hn = 1.0;
		}
		msl_hu = dot(msl_h,msl_u);
		msl_hu *= msl_hu;
		msl_hv = dot(msl_h,msl_v);
		msl_hv *= msl_hv;
		if (msl_hn >= ((0.0001 * ((((msl_hu * msl_shiny_u2)) + ((msl_hv * msl_shiny_v2)))))))
		{
			msl_expo = (((-((((msl_hu * msl_shiny_u2)) + ((msl_hv * msl_shiny_v2))))) / msl_hn));
			msl_result = ((((((exp(msl_expo) * msl_shiny_u)) * msl_shiny_v)) / ((((sqrt(((msl_cosi * msl_cosr))) * 4.0)) * 3.14159265358979323846))));
		}
	}
	return msl_result;
}


vec4 rgb_to_hsv(vec4 msl_rgb)
{
	vec4 msl_result;
	float msl_channelMin, msl_channelMax, msl_delta;
	msl_channelMin = min(msl_rgb.r,min(msl_rgb.g,msl_rgb.b));
	msl_channelMax = max(msl_rgb.r,max(msl_rgb.g,msl_rgb.b));
	msl_result.b = msl_channelMax;
	msl_delta = ((msl_channelMax - msl_channelMin));
	if (msl_channelMax != float(0))
	{
		msl_result.g = ((msl_delta / msl_channelMax));
	}
	else
	{
		msl_result.g = float(0);
		msl_result.r = float((-1));
		return msl_result;
	}
	if (msl_rgb.r == msl_channelMax)
	{
		msl_result.r = ((((msl_rgb.g - msl_rgb.b)) / msl_delta));
	}
	else
	{
		if (msl_rgb.g == msl_channelMax)
		{
			msl_result.r = ((float(2) + ((((msl_rgb.b - msl_rgb.r)) / msl_delta))));
		}
		else
		{
			msl_result.r = ((float(4) + ((((msl_rgb.r - msl_rgb.g)) / msl_delta))));
		}
	}
	msl_result.r *= float(60);
	if (msl_result.r < float(0))
	{
		msl_result.r += float(360);
	}
	return msl_result;
}


vec4 hsv_to_rgb(vec4 msl_hsv)
{
	vec4 msl_result;
	int msl_i;
	float msl_f, msl_p, msl_q, msl_t;
	if (msl_hsv.g == float(0))
	{
		float msl_0 = msl_hsv.b;
		msl_result = vec4(msl_0, msl_0, msl_0, msl_0);
		return msl_result;
	}
	msl_hsv.r /= float(60);
	msl_i = (int (floor(msl_hsv.r)));
	msl_f = ((msl_hsv.r - float(msl_i)));
	msl_p = ((msl_hsv.b * ((float(1) - msl_hsv.g))));
	msl_q = ((msl_hsv.b * ((float(1) - ((msl_hsv.g * msl_f))))));
	msl_t = ((msl_hsv.b * ((float(1) - ((msl_hsv.g * ((float(1) - msl_f))))))));
	if(msl_i==0)
	{
		msl_result.r = msl_hsv.b;
		msl_result.g = msl_t;
		msl_result.b = msl_p;
	}
	else
	if(msl_i==1)
	{
		msl_result.r = msl_q;
		msl_result.g = msl_hsv.b;
		msl_result.b = msl_p;
	}
	else
	if(msl_i==2)
	{
		msl_result.r = msl_p;
		msl_result.g = msl_hsv.b;
		msl_result.b = msl_t;
	}
	else
	if(msl_i==3)
	{
		msl_result.r = msl_p;
		msl_result.g = msl_q;
		msl_result.b = msl_hsv.b;
	}
	else
	if(msl_i==4)
	{
		msl_result.r = msl_t;
		msl_result.g = msl_p;
		msl_result.b = msl_hsv.b;
	}
	else
	{
		msl_result.r = msl_hsv.b;
		msl_result.g = msl_p;
		msl_result.b = msl_q;
	}

	return msl_result;
}


varying vec3 position;
varying vec3 normal;

//
// The following are free parameters of the shader
// that should be set by the application at runtime.
//
uniform vec4 msl_Color_brightness_2_color;
uniform float msl_Color_brightness_2_amount;
uniform vec4 msl_Color_brightness_1_color;
uniform float msl_Color_brightness_1_amount;
uniform float msl_Component_falloff_1_amount;

//
// The following are parameters representing non-varying state variables 
// referenced by the shader. These should be set by the application at runtime.
// Note that vector parameters should be provided in camera space.
//
uniform mat4 object_to_camera;
uniform mat4 object_to_raster;
uniform mat4 camera_to_object;

//
// The following functions are generated from the MetaSL implementation of
// the shaders that are part of the compiled shader graph.
//

void Math_color_mix_1_Color_brightness_main(vec4 msl_color,float msl_amount,State state,out vec4 msl_result)
{
	{
		msl_result = ((msl_color * vec4(msl_amount)));
	}
}


void Math_color_mix_1_Component_falloff_main(float msl_amount,State state,out vec4 msl_result)
{
	{
		float msl_falloff = mi_falloff((state.direction),(state.normal),msl_amount);
		msl_result = vec4(msl_falloff, msl_falloff, msl_falloff, 1.0);
	}
}


void Math_color_mix_1_Math_color_mix_main(vec4 msl_color1,vec4 msl_color2,vec4 msl_mix,State state,out vec4 msl_result)
{
	{
		msl_result = mix(msl_color1,msl_color2,msl_mix);
	}
}


//
// The following method is the root function of the shader graph
//
vec4 Math_color_mix_1_eval(State state)
{
	vec4 msl_result;
	vec4 msl_Color_brightness_2_result = vec4(0.000000, 0.000000, 0.000000, 0.000000);
	Math_color_mix_1_Color_brightness_main(msl_Color_brightness_2_color,msl_Color_brightness_2_amount,(state),msl_Color_brightness_2_result);
	vec4 msl_Color_brightness_1_result = vec4(0.000000, 0.000000, 0.000000, 0.000000);
	Math_color_mix_1_Color_brightness_main(msl_Color_brightness_1_color,msl_Color_brightness_1_amount,(state),msl_Color_brightness_1_result);
	vec4 msl_Component_falloff_1_result = vec4(0.000000, 0.000000, 0.000000, 0.000000);
	Math_color_mix_1_Component_falloff_main(msl_Component_falloff_1_amount,(state),msl_Component_falloff_1_result);
	Math_color_mix_1_Math_color_mix_main(msl_Color_brightness_2_result,msl_Color_brightness_1_result,msl_Component_falloff_1_result,(state),msl_result);
	return msl_result;
}

//
// This function is the main method of the fragment shader. It initializes the
// values in the state structure that are used by nodes in the shader graph
// and produces the final result of the shader.
//
void main()
{
	State state;
	state.position = position;
	state.normal = normalize(normal);
	state.direction = normalize(state.position);
	gl_FragColor = Math_color_mix_1_eval(state);
}
