/*
 * Copyright 2002-2006 Velox Development Team. This file is licenced under the
 * revised BSD licence. See licence_bsd.txt in the root of the Velox 
 * distribution or http://www.sechsta-sinn.de/velox/licence_bsd.txt for the
 * complete licence text
 */

#include <V3d/Physics/VPhysicManager.h> 
#include <V3d/Physics/VStateSphereMass.h>
#include <V3d/Physics/VGeometrySphere.h>
#include <V3d/Physics/VGeometryBox.h>
#include <V3d/Physics/VGeometryPlane.h>
#include <V3d/Physics/VGeometryMesh.h>
#include <v3d/math/VBoundingBox.h>
#include <v3d/math/VBoundingSphere.h>
#include <v3d/Physics/Bounding/VBoundingMesh.h>
#include <algorithm>
//-----------------------------------------------------------------------------
#include <V3d/Core/MemManager.h>
//-----------------------------------------------------------------------------
namespace v3d { namespace  physics{
//-----------------------------------------------------------------------------
using namespace v3d;
using namespace v3d::math;
using namespace std;

VPhysicManager::VPhysicManager() : m_fTimeStep(0.001f)
{
	m_iAutoGeneratedCounter = 0;
	m_fTimeDelta = 0;
}
VPhysicManager::~VPhysicManager()
{
	;
}

void VPhysicManager::RegisterToUpdater()
{
	//Register();
}

void VPhysicManager::UnregisterToUpdater()
{
	//Unregister();
}

void VPhysicManager::Update(vfloat32 in_fSeconds)
{
	//limit time of physic simulation
	//vfloat32 t= 0.0f;
	
	//see if our time is far to high (alt tabbing or initial start up)
	if(in_fSeconds > 2.0f)
		return;

	m_fTimeDelta += in_fSeconds;
	//step small fixed steps forward in time
	while( m_fTimeDelta >= m_fTimeStep )
	{
		//t+=m_fTimeStep;
		//m_World.SetWorldStep(m_fTimeStep);
		m_World.SetWorldStep(m_fTimeStep);
		m_World.Update();
		UpdateBodies();
		//timeDelta -= m_fTimeStep;
		m_fTimeDelta -= m_fTimeStep;
	}
}

void VPhysicManager::UpdateBodies()
{
	typedef BodyList::const_iterator Iter;
	Iter begin = m_BodyList.begin();
	Iter end = m_BodyList.end();

	for(; begin != end; ++begin)
		(*begin)->Update();

	//for_each(begin, end, mem_fun(&VBody::Update));
}

void VPhysicManager::Delete(BodyPtr in_Body)
{
	m_BodyList.remove(in_Body);

	//check if we need to deactivate a joint
	JointList::const_iterator it = m_JointList.begin();
	JointList::const_iterator itEnd = m_JointList.end();
	for ( ; it != itEnd; ++it )
	{
		VBody* pBody1 = (*it)->GetBody1();
		VBody* pBody2 = (*it)->GetBody2();
		
		if(pBody1 == in_Body.Get() || pBody2 == in_Body.Get() )
			(*it)->Destroy();
	}
}

void VPhysicManager::Activate()
{
	;
}

void VPhysicManager::Deactivate()
{
	;
}

std::string VPhysicManager::QueryAvailableIdentifier(std::string in_sIdentifier)
{
	//traverse over all registered bodies and check if name is conflicting
	if( IsRegisteredName(in_sIdentifier) || in_sIdentifier == "" )
	{
		std::string autoIdentifier = "autoGenerated@";
		std::stringstream str;
		str << autoIdentifier << m_iAutoGeneratedCounter;
		m_iAutoGeneratedCounter++;
		if( ! IsRegisteredName(str.str()) )
			return str.str();
		else
			return QueryAvailableIdentifier(in_sIdentifier);
	}
	else
		return in_sIdentifier;
}

vbool VPhysicManager::IsRegisteredName(std::string in_sName)
{
	BodyList::const_iterator it = m_BodyList.begin();
	BodyList::const_iterator itEnd = m_BodyList.end();

	for ( ; it != itEnd; ++it)
	{
		std::string name = (*it)->GetName();
		if ( name == in_sName)
		{
			return true;
		}
	}
	return false;
}

void VPhysicManager::RequestNameChange(std::string in_sName, VBody* in_pBody)
{
	if( ! IsRegisteredName(in_sName) )
	{
		// change the name
		in_pBody->SetName(in_sName);
	}
	else
	{
		; //sorry we can't do this
	}
}

VBody* VPhysicManager::QueryBodyByName(std::string in_sName)
{
	BodyList::const_iterator it = m_BodyList.begin();
	BodyList::const_iterator itEnd = m_BodyList.end();

	for( ; it != itEnd; ++it)
	{
		std::string name = (*it)->GetName();
		if(name == in_sName)
			return (*it).Get();
	}
	return 0;
}

VPhysicManager::Geometry VPhysicManager::CreateGeom(IVBoundingVolumePart* in_pBoundingPart)
{
	VBoundingBox* pBox = in_pBoundingPart->GetBoundingBox();
	VBoundingSphere* pSphere = in_pBoundingPart->GetBoundingSphere();
	math::VPlane* pPlane = in_pBoundingPart->GetBoundingPlane();
	VBoundingMesh* pMesh = 0;

	if( in_pBoundingPart->HasBoundingMesh() )
	{
		pMesh = in_pBoundingPart->GetBoundingMesh();
	}	

	if(pBox)
		return CreateBoxGeom(pBox);
	if(pSphere)
		return CreateSphereGeom(pSphere);
	if(pMesh)
		return CreateMeshGeom(pMesh);
	if(pPlane)
		return CreatePlane(pPlane->GetNormal(), pPlane->GetDistance());
	
	V3D_THROW(VException, "no valid bounding part found");
	Geometry retValue;
	retValue.Assign(0);
	return retValue;
}

VPhysicManager::Geometry VPhysicManager::CreateBoxGeom(VBoundingBox* in_pBoundingBox)
{
	VSharedPtr<VGeometryBox> pGeometryBox(new VGeometryBox());
	pGeometryBox->SetLength(in_pBoundingBox->GetLength().GetX());
	pGeometryBox->SetWidth(in_pBoundingBox->GetLength().GetY());
	pGeometryBox->SetHeight(in_pBoundingBox->GetLength().GetZ());

	pGeometryBox->CreateBox(m_World.GetSpace());
	return pGeometryBox;
}
VPhysicManager::Geometry VPhysicManager::CreateMeshGeom(VBoundingMesh* in_pBoundingMesh)
{
	VSharedPtr<VGeometryMesh> pGeometry(new VGeometryMesh(*in_pBoundingMesh));
	
	pGeometry->Create(m_World.GetSpace());
	return pGeometry;
}

VPhysicManager::Geometry VPhysicManager::CreateSphereGeom(VBoundingSphere* in_pBoundingSphere)
{
	VSharedPtr<VGeometrySphere> pGeometrySphere(new VGeometrySphere());
	pGeometrySphere->SetSphereRadius(in_pBoundingSphere->GetRadius());
	pGeometrySphere->CreateSphere(m_World.GetSpace());
	return pGeometrySphere;
}

VPhysicManager::BodyPtr VPhysicManager::CreateBody(std::string in_sName)
{
	//body will take ownership of odeBody
	VOdeBody* pOdeBody = new VOdeBody();
	pOdeBody->Create(&m_World);
	BodyPtr pBody(new VBody(pOdeBody, in_sName));
	//VSharedPtr<VBodyPart> bodyPart(new VBodyPart(body));
    //return bodyPart;
	return pBody;
}

VPhysicManager::BodyPtr VPhysicManager::Create(IVBoundingVolumePart* in_pBoundingPart,
											   vfloat32 in_fMass,
											   std::string in_sIdentifierName)
{
	//check if name is not already taken

	VBoundingBox* pBox = in_pBoundingPart->GetBoundingBox();
	VBoundingSphere* pSphere = in_pBoundingPart->GetBoundingSphere();
	VBoundingMesh* pMesh = 0;

	if( in_pBoundingPart->HasBoundingMesh() )
	{
		pMesh = in_pBoundingPart->GetBoundingMesh();
	}	

	if(pBox)
		return CreateBox(in_fMass, pBox->GetLength(), in_sIdentifierName);
	if(pSphere)
		return CreateSphere(in_fMass, pSphere->GetRadius(), in_sIdentifierName);
	if(pMesh)
		return CreateMesh(in_fMass, pMesh, in_sIdentifierName);

	return BodyPtr(0);

}

VPhysicManager::BodyPtr VPhysicManager::CreateSphere(
	vfloat32 in_fMass,
	vfloat32 in_fRadius,
	std::string	in_sName
	)
{
	BodyPtr pBody = CreateBody(in_sName);

	//physic stuff
	VStateSphereMass* pMassState(new VStateSphereMass(pBody->GetOdeBody())); //FIXME: no deletion!!!!!!!!!
	VGeometrySphere* pSphereGeometry(new VGeometrySphere());//FIXME: no deletion!!!!!!!!!
	//assign values
	pMassState->SetMass(in_fMass);
	pMassState->SetRadius(in_fRadius);
	pBody->Add(pMassState);
	
	pSphereGeometry->SetSphereRadius(in_fRadius);
	pSphereGeometry->CreateSphere(m_World.GetSpace());

	pBody->SetCollisionMesh(pSphereGeometry);
	
	m_BodyList.push_back(pBody);
	
	return pBody;
}

VPhysicManager::BodyPtr VPhysicManager::CreateBox(
	vfloat32 in_fMass,
	VVector3f in_Expansion,
	std::string in_sName)
{
	BodyPtr pBody = CreateBody(in_sName);

	VStateBoxMass* pMassState(new VStateBoxMass(pBody->GetOdeBody())); //!!!!!
	VGeometryBox* pGeometryBox(new VGeometryBox());//!!!

	pMassState->SetMass(in_fMass);
	pMassState->SetLength(in_Expansion[0]); //fix this settings!!
	pMassState->SetWidth(in_Expansion[1]);
	pMassState->SetHeight(in_Expansion[2]);

	pGeometryBox->SetLength(in_Expansion[0]);
	pGeometryBox->SetWidth(in_Expansion[1]);
	pGeometryBox->SetHeight(in_Expansion[2]);

	pGeometryBox->CreateBox(m_World.GetSpace());
	pBody->Add(pMassState);
	
	pBody->SetCollisionMesh(pGeometryBox);

	m_BodyList.push_back(pBody);
	return pBody;
}

VPhysicManager::BodyPtr VPhysicManager::CreateMesh(
	vfloat32 in_fMass,
	VBoundingMesh* in_BoundingMesh,
	std::string in_sName)
{
	BodyPtr pBody = CreateBody(in_sName);

	VStateBoxMass* pMassState(new VStateBoxMass(pBody->GetOdeBody()));
	VGeometryMesh* pGeometryMesh(new VGeometryMesh(*in_BoundingMesh));

	pMassState->SetMass(in_fMass);
	pGeometryMesh->Create(m_World.GetSpace());
	pBody->Add(pMassState);
	pBody->SetCollisionMesh(pGeometryMesh);

	m_BodyList.push_back(pBody);

	return pBody;
}

VPhysicManager::Geometry VPhysicManager::CreatePlane(
	VVector3f in_Normal,
	vfloat32 in_fDistance
	)
{
	VSharedPtr<VGeometryPlane> pGeometryPlane(new VGeometryPlane());
	
	pGeometryPlane->SetPlane(graphics::VVertex3f(in_Normal[0], in_Normal[1], in_Normal[2]),in_fDistance);
	pGeometryPlane->CreatePlane(m_World.GetSpace());
	
	return pGeometryPlane;
}

//void VPhysicManager::LinkBody(
//      VPhysicManager::BodyPtr in_pBody1,
//	  VPhysicManager::BodyPtr in_pBody2,
//	  VPhysicManager::JointPtr in_LinkMode)
//{
//	in_LinkMode->Create(&m_World);
//	in_LinkMode->AddBody(in_pBody1.Get(), in_pBody2.Get());
//	in_LinkMode->Apply();
//}

void VPhysicManager::DeleteCollisionMesh(VGeometry* in_Geometry)
{
	V3D_ASSERT(in_Geometry != 0);
	m_World.RemoveCollisionMesh(*in_Geometry->GetGeomID());
	delete in_Geometry;
}

VWorld* VPhysicManager::GetWorld()
{
	return &m_World;
}

vuint VPhysicManager::GetPhysicObjectCount()
{
	return static_cast<vuint>(m_BodyList.size());
}

void VPhysicManager::RegisterJoint(VJointHinge2* in_pJoint)
{
	if(in_pJoint)
	{
		JointList::const_iterator it = m_JointList.begin();
		JointList::const_iterator itEnd = m_JointList.end();
		for ( ; it != itEnd; ++it)
		{
			if(in_pJoint == (*it) )
				return;
		}

		m_JointList.push_back(in_pJoint);
	}
}
void VPhysicManager::UnregisterJoint(VJointHinge2* in_pJoint)
{
	if(in_pJoint)
		m_JointList.remove(in_pJoint);
}

void VPhysicManager::RefreshJoint(VBody* in_pBody)
{
	////check if body has any connections to joints
	//JointList::const_iterator it = m_JointList.begin();
	//JointList::const_iterator itEnd = m_JointList.end();

	//for( ; it != itEnd; ++it)
	//{
	//	VBody* pBody1 = (*it)->GetBody1();
	//	VBody* pBody2 = (*it)->GetBody2();

	//	//joint exists, thats connected and needs to be reseted
	//	if(pBody1 == in_pBody || pBody2 == in_pBody)
	//	{
	//		(*it)->Destroy();
	//		(*it)->Create(this->GetWorld());
	//	}
	//}
}

//-----------------------------------------------------------------------------
}} // namespace v3d::
//-----------------------------------------------------------------------------

